diff -ur pygame-1.7.1release.orig/src/event.c pygame-1.7.1release/src/event.c
--- pygame-1.7.1release.orig/src/event.c	2005-08-15 04:11:40.000000000 -0700
+++ pygame-1.7.1release/src/event.c	2007-05-15 19:03:55.000000000 -0700
@@ -534,7 +534,7 @@
 	if(keywords)
 	{
 		PyObject *key, *value;
-		int pos  = 0;
+		Py_ssize_t pos  = 0;
 		while(PyDict_Next(keywords, &pos, &key, &value))
 			PyDict_SetItem(dict, key, value);
 	}
diff -ur pygame-1.7.1release.orig/src/image.c pygame-1.7.1release/src/image.c
--- pygame-1.7.1release.orig/src/image.c	2005-03-12 17:12:35.000000000 -0800
+++ pygame-1.7.1release/src/image.c	2007-05-15 19:03:55.000000000 -0700
@@ -291,7 +291,8 @@
 	PyObject *surfobj, *string=NULL;
 	char *format, *data, *pixels;
 	SDL_Surface *surf, *temp=NULL;
-	int w, h, color, len, flipped=0;
+	int w, h, color, flipped=0;
+	Py_ssize_t len;
 	int Rmask, Gmask, Bmask, Amask, Rshift, Gshift, Bshift, Ashift, Rloss, Gloss, Bloss, Aloss;
 	int hascolorkey, colorkey;
 
@@ -605,7 +606,8 @@
 	PyObject *string;
 	char *format, *data;
 	SDL_Surface *surf = NULL;
-	int w, h, len, flipped=0;
+	int w, h, flipped=0;
+	Py_ssize_t len;
 	int loopw, looph;
 
 	if(!PyArg_ParseTuple(arg, "O!(ii)s|i", &PyString_Type, &string, &w, &h, &format, &flipped))
@@ -729,7 +731,8 @@
 	PyObject *buffer;
 	char *format, *data;
 	SDL_Surface *surf = NULL;
-	int w, h, len;
+	int w, h;
+	Py_ssize_t len;
         PyObject *surfobj;
 
 	if(!PyArg_ParseTuple(arg, "O(ii)s|i", &buffer, &w, &h, &format))
diff -ur pygame-1.7.1release.orig/src/mixer.c pygame-1.7.1release/src/mixer.c
--- pygame-1.7.1release.orig/src/mixer.c	2005-08-10 23:14:27.000000000 -0700
+++ pygame-1.7.1release/src/mixer.c	2007-05-15 19:03:40.000000000 -0700
@@ -81,7 +81,7 @@
 	    channeldata[channel].queue = NULL;
 	    channelnum = Mix_PlayChannelTimed(channel, sound, 0, -1);
 	    if(channelnum != -1)
-	    	Mix_GroupChannel(channelnum, (int)sound);
+	    	Mix_GroupChannel(channelnum, (intptr_t)sound);
 	}
 	else
 	{
@@ -354,7 +354,7 @@
 	//make sure volume on this arbitrary channel is set to full
 	Mix_Volume(channelnum, 128);
 
-	Mix_GroupChannel(channelnum, (int)chunk);
+	Mix_GroupChannel(channelnum, (intptr_t)chunk);
 	return PyChannel_New(channelnum);
 }
 
@@ -378,7 +378,7 @@
 
 	MIXER_INIT_CHECK();
 
-	return PyInt_FromLong(Mix_GroupCount((int)chunk));
+	return PyInt_FromLong(Mix_GroupCount((intptr_t)chunk));
 }
 
 
@@ -440,7 +440,7 @@
 
 	MIXER_INIT_CHECK();
 
-	Mix_FadeOutGroup((int)chunk, time);
+	Mix_FadeOutGroup((intptr_t)chunk, time);
 	RETURN_NONE
 }
 
@@ -460,7 +460,7 @@
 
 	MIXER_INIT_CHECK();
 
-	Mix_HaltGroup((int)chunk);
+	Mix_HaltGroup((intptr_t)chunk);
 	RETURN_NONE
 }
 
@@ -661,7 +661,7 @@
 
 	channelnum = Mix_PlayChannelTimed(channelnum, chunk, loops, playtime);
 	if(channelnum != -1)
-		Mix_GroupChannel(channelnum, (int)chunk);
+		Mix_GroupChannel(channelnum, (intptr_t)chunk);
 
         Py_XDECREF(channeldata[channelnum].sound);
 	Py_XDECREF(channeldata[channelnum].queue);
@@ -705,7 +705,7 @@
 	{
 	    channelnum = Mix_PlayChannelTimed(channelnum, chunk, 0, -1);
 	    if(channelnum != -1)
-		    Mix_GroupChannel(channelnum, (int)chunk);
+		    Mix_GroupChannel(channelnum, (intptr_t)chunk);
 
             channeldata[channelnum].sound = sound;
             Py_INCREF(sound);
diff -ur pygame-1.7.1release.orig/src/overlay.c pygame-1.7.1release/src/overlay.c
--- pygame-1.7.1release.orig/src/overlay.c	2005-08-09 19:45:15.000000000 -0700
+++ pygame-1.7.1release/src/overlay.c	2007-05-15 19:03:40.000000000 -0700
@@ -85,7 +85,7 @@
 {
 	// Parse data params for frame
 	int ls_y, ls_u, ls_v, y;
-	unsigned char *dst_y, *dst_u, *dst_v, *src_y, *src_u, *src_v;
+	void *dst_y, *dst_u, *dst_v, *src_y, *src_u, *src_v;
 	if(!PyArg_ParseTuple(args, "(s#s#s#)", &src_y, &ls_y, &src_u, &ls_u, &src_v, &ls_v))
 		return NULL;
 
@@ -94,9 +94,9 @@
 		SDL_LockYUVOverlay( self->cOverlay );
 
 		// No clipping at this time( only support for YUV420 )
-		dst_y = (char*)self->cOverlay->pixels[ 0 ];
-		dst_v = (char*)self->cOverlay->pixels[ 1 ];
-		dst_u = (char*)self->cOverlay->pixels[ 2 ];
+		dst_y = (void*)self->cOverlay->pixels[ 0 ];
+		dst_v = (void*)self->cOverlay->pixels[ 1 ];
+		dst_u = (void*)self->cOverlay->pixels[ 2 ];
 		for (y=0; y< self->cOverlay->h; y++)
 		{
 			memcpy( dst_y, src_y, self->cOverlay->w );
diff -ur pygame-1.7.1release.orig/src/rect.c pygame-1.7.1release/src/rect.c
--- pygame-1.7.1release.orig/src/rect.c	2004-07-18 18:39:49.000000000 -0700
+++ pygame-1.7.1release/src/rect.c	2007-05-15 19:05:10.000000000 -0700
@@ -937,7 +937,7 @@
 
 /* sequence functions */
 
-static int rect_length(PyRectObject *self)
+static Py_ssize_t rect_length(PyObject *_self)
 {
 	return 4;
 }
diff -ur pygame-1.7.1release.orig/src/surface.c pygame-1.7.1release/src/surface.c
--- pygame-1.7.1release.orig/src/surface.c	2005-02-05 16:03:07.000000000 -0800
+++ pygame-1.7.1release/src/surface.c	2007-05-15 19:03:55.000000000 -0700
@@ -35,7 +35,7 @@
                         SDL_Surface *dst, SDL_Rect *dstrect);
 
 static PyObject* surface_new(PyTypeObject *type, PyObject *args, PyObject *kwds);
-static int surface_init(PySurfaceObject *self, PyObject *args, PyObject *kwds);
+static intptr_t surface_init(PySurfaceObject *self, PyObject *args, PyObject *kwds);
 
 
 /* surface object methods */
@@ -1353,7 +1353,7 @@
 	if(rect && kw)
 	{
 		PyObject *key, *value;
-		int pos=0;
+		Py_ssize_t pos=0;
 		while(PyDict_Next(kw, &pos, &key, &value))
 		{
 			if((PyObject_SetAttr(rect, key, value) == -1))
@@ -1880,7 +1880,7 @@
     return (PyObject *)self;
 }
 
-static int surface_init(PySurfaceObject *self, PyObject *args, PyObject *kwds)
+static intptr_t surface_init(PySurfaceObject *self, PyObject *args, PyObject *kwds)
 {
 	Uint32 flags = 0;
 	int width, height;
@@ -1904,19 +1904,19 @@
 	if(depth && masks) /*all info supplied, most errorchecking needed*/
 	{
 		if(PySurface_Check(depth))
-			return (int)RAISE(PyExc_ValueError, "cannot pass surface for depth and color masks");
+			return (intptr_t)RAISE(PyExc_ValueError, "cannot pass surface for depth and color masks");
 		if(!IntFromObj(depth, &bpp))
-			return (int)RAISE(PyExc_ValueError, "invalid bits per pixel depth argument");
+			return (intptr_t)RAISE(PyExc_ValueError, "invalid bits per pixel depth argument");
 		if(!PySequence_Check(masks) || PySequence_Length(masks)!=4)
-			return (int)RAISE(PyExc_ValueError, "masks argument must be sequence of four numbers");
+			return (intptr_t)RAISE(PyExc_ValueError, "masks argument must be sequence of four numbers");
 		if(!UintFromObjIndex(masks, 0, &Rmask) || !UintFromObjIndex(masks, 1, &Gmask) ||
 					!UintFromObjIndex(masks, 2, &Bmask) || !UintFromObjIndex(masks, 3, &Amask))
-			return (int)RAISE(PyExc_ValueError, "invalid mask values in masks sequence");
+			return (intptr_t)RAISE(PyExc_ValueError, "invalid mask values in masks sequence");
 	}
 	else if(depth && PyNumber_Check(depth))/*use default masks*/
 	{
 		if(!IntFromObj(depth, &bpp))
-			return (int)RAISE(PyExc_ValueError, "invalid bits per pixel depth argument");
+			return (intptr_t)RAISE(PyExc_ValueError, "invalid bits per pixel depth argument");
 		if(flags & SDL_SRCALPHA)
 		{
 			switch(bpp)
@@ -1926,7 +1926,7 @@
 			case 32:
 				Rmask = 0xFF<<16; Gmask = 0xFF<<8; Bmask = 0xFF; Amask = 0xFF<<24; break;
 			default:
-				return (int)RAISE(PyExc_ValueError, "no standard masks exist for given bitdepth with alpha");
+				return (intptr_t)RAISE(PyExc_ValueError, "no standard masks exist for given bitdepth with alpha");
 			}
 		}
 		else
@@ -1946,7 +1946,7 @@
 			case 32:
 				Rmask = 0xFF<<16; Gmask = 0xFF<<8; Bmask = 0xFF; break;
 			default:
-				return (int)RAISE(PyExc_ValueError, "nonstandard bit depth given");
+				return (intptr_t)RAISE(PyExc_ValueError, "nonstandard bit depth given");
 			}
 		}
 	}
diff -ur pygame-1.7.1release.orig/src/time.c pygame-1.7.1release/src/time.c
--- pygame-1.7.1release.orig/src/time.c	2004-07-22 17:33:08.000000000 -0700
+++ pygame-1.7.1release/src/time.c	2007-05-15 19:03:40.000000000 -0700
@@ -34,7 +34,7 @@
 	{
 		SDL_Event event;
 		memset(&event, 0, sizeof(event));
-		event.type = (int)param;
+		event.type = (intptr_t)param;
 		SDL_PushEvent(&event);
 	}
 	return interval;
@@ -193,7 +193,8 @@
 static PyObject* time_set_timer(PyObject* self, PyObject* arg)
 {
 	SDL_TimerID newtimer;
-	int ticks = 0, event = SDL_NOEVENT;
+	int ticks = 0;
+	intptr_t event = SDL_NOEVENT;
 	if(!PyArg_ParseTuple(arg, "ii", &event, &ticks))
 		return NULL;

